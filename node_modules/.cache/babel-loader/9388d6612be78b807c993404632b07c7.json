{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getDimensions = getDimensions;\nexports.getPositionOffset = getPositionOffset;\nexports.getScrollOffset = getScrollOffset;\n/**\n * Gets the dimensions of the element, accounting for API differences between\n * `window` and other DOM elements.\n */\n// TODO Move this into WindowScroller and import from there\n\nvar isWindow = function isWindow(element) {\n  return element === window;\n};\n\nvar getBoundingBox = function getBoundingBox(element) {\n  return element.getBoundingClientRect();\n};\n\nfunction getDimensions(scrollElement, props) {\n  if (!scrollElement) {\n    return {\n      height: props.serverHeight,\n      width: props.serverWidth\n    };\n  } else if (isWindow(scrollElement)) {\n    var _window = window,\n        innerHeight = _window.innerHeight,\n        innerWidth = _window.innerWidth;\n    return {\n      height: typeof innerHeight === 'number' ? innerHeight : 0,\n      width: typeof innerWidth === 'number' ? innerWidth : 0\n    };\n  } else {\n    return getBoundingBox(scrollElement);\n  }\n}\n/**\n * Gets the vertical and horizontal position of an element within its scroll container.\n * Elements that have been “scrolled past” return negative values.\n * Handles edge-case where a user is navigating back (history) from an already-scrolled page.\n * In this case the body’s top or left position will be a negative number and this element’s top or left will be increased (by that amount).\n */\n\n\nfunction getPositionOffset(element, container) {\n  if (isWindow(container) && document.documentElement) {\n    var containerElement = document.documentElement;\n    var elementRect = getBoundingBox(element);\n    var containerRect = getBoundingBox(containerElement);\n    return {\n      top: elementRect.top - containerRect.top,\n      left: elementRect.left - containerRect.left\n    };\n  } else {\n    var scrollOffset = getScrollOffset(container);\n\n    var _elementRect = getBoundingBox(element);\n\n    var _containerRect = getBoundingBox(container);\n\n    return {\n      top: _elementRect.top + scrollOffset.top - _containerRect.top,\n      left: _elementRect.left + scrollOffset.left - _containerRect.left\n    };\n  }\n}\n/**\n * Gets the vertical and horizontal scroll amount of the element, accounting for IE compatibility\n * and API differences between `window` and other DOM elements.\n */\n\n\nfunction getScrollOffset(element) {\n  if (isWindow(element) && document.documentElement) {\n    return {\n      top: 'scrollY' in window ? window.scrollY : document.documentElement.scrollTop,\n      left: 'scrollX' in window ? window.scrollX : document.documentElement.scrollLeft\n    };\n  } else {\n    return {\n      top: element.scrollTop,\n      left: element.scrollLeft\n    };\n  }\n}","map":{"version":3,"sources":["/home/mathews/Reesby/React/NewMalihUI/emilusAntTheme-main/Emilus - React Admin Template/demo/node_modules/react-virtualized/dist/commonjs/WindowScroller/utils/dimensions.js"],"names":["Object","defineProperty","exports","value","getDimensions","getPositionOffset","getScrollOffset","isWindow","element","window","getBoundingBox","getBoundingClientRect","scrollElement","props","height","serverHeight","width","serverWidth","_window","innerHeight","innerWidth","container","document","documentElement","containerElement","elementRect","containerRect","top","left","scrollOffset","_elementRect","_containerRect","scrollY","scrollTop","scrollX","scrollLeft"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getDimensions = getDimensions;\nexports.getPositionOffset = getPositionOffset;\nexports.getScrollOffset = getScrollOffset;\n\n/**\n * Gets the dimensions of the element, accounting for API differences between\n * `window` and other DOM elements.\n */\n// TODO Move this into WindowScroller and import from there\nvar isWindow = function isWindow(element) {\n  return element === window;\n};\n\nvar getBoundingBox = function getBoundingBox(element) {\n  return element.getBoundingClientRect();\n};\n\nfunction getDimensions(scrollElement, props) {\n  if (!scrollElement) {\n    return {\n      height: props.serverHeight,\n      width: props.serverWidth\n    };\n  } else if (isWindow(scrollElement)) {\n    var _window = window,\n        innerHeight = _window.innerHeight,\n        innerWidth = _window.innerWidth;\n    return {\n      height: typeof innerHeight === 'number' ? innerHeight : 0,\n      width: typeof innerWidth === 'number' ? innerWidth : 0\n    };\n  } else {\n    return getBoundingBox(scrollElement);\n  }\n}\n/**\n * Gets the vertical and horizontal position of an element within its scroll container.\n * Elements that have been “scrolled past” return negative values.\n * Handles edge-case where a user is navigating back (history) from an already-scrolled page.\n * In this case the body’s top or left position will be a negative number and this element’s top or left will be increased (by that amount).\n */\n\n\nfunction getPositionOffset(element, container) {\n  if (isWindow(container) && document.documentElement) {\n    var containerElement = document.documentElement;\n    var elementRect = getBoundingBox(element);\n    var containerRect = getBoundingBox(containerElement);\n    return {\n      top: elementRect.top - containerRect.top,\n      left: elementRect.left - containerRect.left\n    };\n  } else {\n    var scrollOffset = getScrollOffset(container);\n\n    var _elementRect = getBoundingBox(element);\n\n    var _containerRect = getBoundingBox(container);\n\n    return {\n      top: _elementRect.top + scrollOffset.top - _containerRect.top,\n      left: _elementRect.left + scrollOffset.left - _containerRect.left\n    };\n  }\n}\n/**\n * Gets the vertical and horizontal scroll amount of the element, accounting for IE compatibility\n * and API differences between `window` and other DOM elements.\n */\n\n\nfunction getScrollOffset(element) {\n  if (isWindow(element) && document.documentElement) {\n    return {\n      top: 'scrollY' in window ? window.scrollY : document.documentElement.scrollTop,\n      left: 'scrollX' in window ? window.scrollX : document.documentElement.scrollLeft\n    };\n  } else {\n    return {\n      top: element.scrollTop,\n      left: element.scrollLeft\n    };\n  }\n}"]},"metadata":{},"sourceType":"script"}